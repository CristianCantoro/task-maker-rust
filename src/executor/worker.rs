use crate::execution::*;
use crate::executor::*;
use crate::store::*;
use failure::{Error, Fail};
use std::sync::mpsc::channel;
use std::sync::{Arc, Mutex};
use std::thread;
use uuid::Uuid;

/// The identifier of a worker, it's globally unique and identifies the worker
/// during a single connection.
pub type WorkerUuid = Uuid;

/// The worker is the component that receives the work from the server and
/// sends the results back.
pub struct Worker {
    /// The identifier of this worker
    pub uuid: WorkerUuid,
    /// The name of this worker
    pub name: String,
    /// The channel that sends messages to the server
    pub sender: ChannelSender,
    /// The channel that receives messages from the server
    pub receiver: ChannelReceiver,
    /// A reference to the FileStore
    pub file_store: Arc<Mutex<FileStore>>,
}

/// An handle of the connection to the worker
pub struct WorkerConn {
    /// The identifier of the worker
    pub uuid: WorkerUuid,
    /// The name of the worker
    pub name: String,
    /// The channel that sends messages to the worker
    pub sender: ChannelSender,
    /// The channel that receives messages from the server
    pub receiver: ChannelReceiver,
}

/// An error generated by the worker
#[derive(Debug, Fail)]
pub enum WorkerError {
    #[fail(display = "missing key for dependency {}", uuid)]
    MissingDependencyKey { uuid: Uuid },
}

impl Worker {
    /// Make a new worker attached to a FileStore, will return a pair with the
    /// actual Worker and an handle with the channels to connect to communicate
    /// with the worker.
    pub fn new(name: &str, file_store: Arc<Mutex<FileStore>>) -> (Worker, WorkerConn) {
        let (tx, rx_worker) = channel();
        let (tx_worker, rx) = channel();
        let uuid = Uuid::new_v4();
        (
            Worker {
                uuid: uuid.clone(),
                name: name.to_owned(),
                sender: tx_worker,
                receiver: rx_worker,
                file_store: file_store,
            },
            WorkerConn {
                uuid: uuid,
                name: name.to_owned(),
                sender: tx,
                receiver: rx,
            },
        )
    }

    /// The worker body, this function will block.
    pub fn work(self) -> Result<(), Error> {
        trace!("Worker {} ready, asking for work", self);
        serialize_into(&WorkerClientMessage::GetWork, &self.sender)?;
        let mut current_job = None;
        let mut missing_deps = 0;
        loop {
            let message = deserialize_from::<WorkerServerMessage>(&self.receiver);
            match message {
                Ok(WorkerServerMessage::Work(job)) => {
                    trace!("Worker {} got job: {:?}", self, job);
                    for input in job.execution.dependencies().iter() {
                        let mut store = self.file_store.lock().unwrap();
                        let key =
                            job.dep_keys
                                .get(&input)
                                .ok_or(WorkerError::MissingDependencyKey {
                                    uuid: input.clone(),
                                })?;
                        if !store.has_key(&key) {
                            serialize_into(
                                &WorkerClientMessage::AskFile(input.clone()),
                                &self.sender,
                            )?;
                            missing_deps += 1;
                        }
                    }
                    current_job = Some(job);
                    if missing_deps == 0 {
                        let mut store = self.file_store.lock().unwrap();
                        execute_job(current_job.as_ref().unwrap(), &self.sender, &mut store)?;
                        current_job = None;
                        serialize_into(&WorkerClientMessage::GetWork, &self.sender)?;
                    }
                }
                Ok(WorkerServerMessage::ProvideFile(uuid, key)) => {
                    info!("Server sent file {} {:?}", uuid, key);
                    let mut store = self.file_store.lock().unwrap();
                    let reader = ChannelFileIterator::new(&self.receiver);
                    store.store(&key, reader)?;
                    missing_deps -= 1;
                    if missing_deps == 0 {
                        execute_job(current_job.as_ref().unwrap(), &self.sender, &mut store)?;
                        current_job = None;
                        serialize_into(&WorkerClientMessage::GetWork, &self.sender)?;
                    }
                }
                Err(e) => {
                    let cause = e.find_root_cause().to_string();
                    if cause == "receiving on a closed channel" {
                        trace!("Connection closed: {}", cause);
                        break;
                    } else {
                        error!("Connection error: {}", cause);
                    }
                }
            }
        }
        Ok(())
    }
}

fn execute_job(
    job: &WorkerJob,
    sender: &ChannelSender,
    file_store: &mut FileStore,
) -> Result<(), Error> {
    let sandbox = Sandbox::new(
        std::path::Path::new("/tmp/sandboxes"),
        &job.execution,
        &job.dep_keys,
        file_store,
    )?;
    thread::sleep(std::time::Duration::from_secs(1));
    serialize_into(
        &WorkerClientMessage::WorkerDone(WorkerResult {
            result: ExecutionResult {
                uuid: job.execution.uuid.clone(),
                status: ExecutionStatus::Success,
            },
        }),
        sender,
    )?;
    for out in job.execution.outputs() {
        let path = std::path::Path::new("/dev/null");
        serialize_into(
            &WorkerClientMessage::ProvideFile(out.clone(), FileStoreKey::from_file(path)?),
            sender,
        )
        .unwrap();
        ChannelFileSender::send(path, sender)?;
    }
    Ok(())
}

impl std::fmt::Display for WorkerConn {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        write!(f, "'{}' ({})", self.name, self.uuid)
    }
}

impl std::fmt::Display for Worker {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        write!(f, "'{}' ({})", self.name, self.uuid)
    }
}

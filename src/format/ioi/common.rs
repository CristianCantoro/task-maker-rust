use crate::format::*;
use serde::{Deserialize, Serialize};
use std::path::{Path, PathBuf};

/// In IOI tasks the subtask numbers are non-negative integers
pub type IOISubtaskId = u32;
/// In IOI tasks the testcase numbers are non-negative integers
pub type IOITestcaseId = u32;

/// Information about a generic IOI task
pub struct IOITaskInfo {
    /// The information from the yaml file
    pub yaml: IOITaskYAML,

    pub testcases: (),
    pub subtasks: (),
    pub checker: (),
}

/// Deserialized data from the task.yaml of a IOI format task
#[derive(Debug, Serialize, Deserialize)]
pub struct IOITaskYAML {
    /// The name of the task (the short one)
    #[serde(alias = "nome")]
    pub name: String,
    /// The title of the task (the long one)
    #[serde(alias = "titolo")]
    pub title: String,
    /// The number of input files, if not provided will be autodetected
    pub n_input: Option<u32>,
    /// The score mode to use for this task.
    ///
    /// TODO!
    pub score_mode: Option<String>,
    /// The token mode of this task.
    ///
    /// This is ignored by task-maker.
    pub token_mode: Option<String>,

    /// The timelimit for the execution of the solutions, if not set it's
    /// unlimited
    #[serde(alias = "timeout")]
    pub time_limit: Option<f64>,
    /// The memory limit in MiB of the execution of the solution, if not set
    /// it's unlimited.
    #[serde(alias = "memlimit")]
    pub memory_limit: Option<u64>,
    /// A list of comma separated numbers of the testcases with the feedback,
    /// can be set to "all".
    ///
    /// This is ignored by task-maker.
    #[serde(alias = "risultati")]
    pub public_testcases: Option<String>,
    /// Whether this is an output only task. Defaults to false.
    #[serde(default = "bool::default")]
    pub output_only: bool,
    /// The maximum score of this task, if it's not set it will be
    /// autodetected from the testcase definition.
    pub total_value: Option<f64>,
    /// The input file for the solutions, usually 'input.txt' or '' (stdin)
    pub infile: String,
    /// The output file for the solutions, usually 'output.txt' or '' (stdout).
    pub outfile: String,
    /// The primary language for this task.
    pub primary_language: Option<String>,
}

/// A subtask of a IOI task
pub struct IOISubtaskInfo {
    /// The maximum score of the subtask, must be >= 0
    pub max_score: f64,
    /// The score mode of the subtask
    pub score_mode: String,
}

/// A testcase of a IOI task. Every testcase has an input and an output that
/// will be put in the input/ and output/ folders. The files are written there
/// only if it's not a dry-run and if the files are not static.
pub struct IOITestcaseInfo {
    /// The number of the testcase
    pub testcase: IOITestcaseId,
    /// Whether the input file has not been generated by a generator.
    pub is_input_static: bool,
    /// Whether the output file has not been generated by a solution.
    pub is_output_static: bool,
}

impl SubtaskInfo for IOISubtaskInfo {
    fn max_score(&self) -> f64 {
        self.max_score
    }
    fn score_mode(&self) -> String {
        self.score_mode.clone()
    }
}

impl TestcaseInfo for IOITestcaseInfo {
    fn write_input_to(&self) -> Option<PathBuf> {
        // do not write the input file if it comes from this path and there is
        // not a generator.
        if self.is_input_static {
            return None;
        }
        Some(Path::new("input").join(format!("input{}.txt", self.testcase)))
    }

    fn write_output_to(&self) -> Option<PathBuf> {
        // do not write the output file if it comes from this path and there is
        // not an official solution.
        if self.is_output_static {
            return None;
        }
        Some(Path::new("output").join(format!("output{}.txt", self.testcase)))
    }
}
